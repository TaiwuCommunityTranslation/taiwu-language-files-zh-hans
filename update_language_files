#!/usr/bin/env ruby

require "fileutils"
require "json"
require "rubygems"
require "set"
require "tempfile"
require "yaml"

require "active_support/inflector"
require "lz4-ruby"

require_relative "unity_bundle"
require_relative "assets"

GAME_DIR="#{Dir.home}/.local/share/Steam/steamapps/common/The Scroll Of Taiwu"
MANAGED_ASSEMBLY="#{GAME_DIR}/The Scroll of Taiwu_Data/Managed/Assembly-CSharp.dll"
LANGUAGE_CN_ASSET_BUNDLE="#{GAME_DIR}/The Scroll of Taiwu_Data/GameResources/language_cn.uab"
EVENTS_DIR="#{GAME_DIR}/Event/EventLanguages"
OUTPUT_DIR="zh-hans"

class Lz4Uncompress
  def initialize(uncompressed_size)
    @uncompressed_size = uncompressed_size
  end

  def decode(compressed)
    return compressed if compressed.bytesize == @uncompressed_size

    uncompressed = LZ4::Raw::decompress(compressed, @uncompressed_size).first
    raise StandardError, "expected #{@uncompressed_size} bytes, got #{uncompressed.length} bytes" if @uncompressed_size != uncompressed.length

    uncompressed
  end
end

def enum_to_string(type)
  type.class_id.to_s.gsub(/\Aclass_id_unity_(.+)_[0-9a-f]{32}_\d+\z/, '\1').camelize
end

ub = UnityBundle.from_file(LANGUAGE_CN_ASSET_BUNDLE)
ub_data = ub.blocks.map(&:data).join

FileUtils.mkdir_p(OUTPUT_DIR)
ub.block_info_and_directory.data.directory_info.each do |ub_info|
  # a_name = ub_info.path
  # puts "[+] update #{a_name}..."

  a_data = ub_data[ub_info.offset, ub_info.size]
  a_path = Tempfile.new
  File.binwrite(a_path, a_data)
  a = Assets.from_file(a_path)

  a.metadata.objects.data.each do |object|
    type = enum_to_string(object)
    next unless type == "TextAsset"

    data = object.data

    name = data.m_name.data
    text = data.m_script.data
    lines = text.split("\n")

    abort "not a language file: #{name}" unless name.end_with?("_language")

    puts "  [+] saving #{name}..."
    if name == "ui_language"
      keys_yaml = `
        ilspycmd -t LanguageKey '#{MANAGED_ASSEMBLY}' \
          | awk '/private static readonly Dictionary<string, ushort> _filedIdMap = new Dictionary<string, ushort>/,/};/' \
          | grep -E '\\{[^}]+\\}' -o | sed -E 's/^\\{ "([^"]+)", ([0-9]+) \\}$/\\1: \\2/g'
      `
      keys = YAML.safe_load(keys_yaml)
      entries = keys.transform_values { |id| lines[id] }
      next File.write(File.join(OUTPUT_DIR, "#{name}.json"), JSON.pretty_generate(entries))
    end

    File.binwrite(File.join(OUTPUT_DIR, "#{name}.txt"), text)
  end
end

def parse_events(file)
  yaml = `
    cat '#{file}' \
      | tr -d '\\r' \
      | sed -E 's/\\t- EventName(.*)/  EventName\\1\\n  EventData:/g' \
      | sed -E 's/\\t\\t-- /    /g' \
      | sed -E 's/(Group|GroupName|Language|EventGuid|EventName|EventData|EventContent|Option_[0-9]+) : (.*)$/\\1: "\\2"/' \
      | sed 's/\\v/\\\\v/g'
  `
  events = YAML.safe_load(yaml)
  abort "invalid events" unless events.is_a?(Array)
  events.filter { |event| event["EventGuid"] }
end

puts "  [+] saving EventLanguages..."
event_list = {}

event_files = Dir["#{EVENTS_DIR}/*.txt"]
event_files.each do |event_file|
  puts "    [+] processing #{File.basename(event_file)}..."
  parse_events(event_file).each do |event|
    guid = event["EventGuid"]
    event_list[guid] = event
  end
end

event_language = {}
event_list.sort_by(&:first).each do |guid, event|
  name, data = event.values_at(*%w[EventName EventData])
  abort "empty name for event #{guid}" if name.nil?
  abort "empty data for event #{guid}" if data.nil?
  event_language["GUID-#{guid}-EventName"] = name
  data.each do |key, value|
    event_language["GUID-#{guid}-#{key}"] = value
  end
end

File.binwrite(File.join(OUTPUT_DIR, "event_language.json"), JSON.pretty_generate(event_language))
